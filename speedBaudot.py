#!/usr/bin/env python3# -*- coding: utf-8 -*-import osfrom datetime import datetimefrom importlib import reloadfrom bisect import bisect# import matplotlib.gridspec as gridspec# import matplotlib.patches as patchesimport matplotlib.pyplot as pltimport numpy as npimport pandas as pd#from mpl_toolkits.axes_grid1.inset_locator import inset_axes# from matplotlib import markers# from matplotlib.patches import Rectangle# from pandas.plotting import tableimport config# import fig_proposal as figp# import general_functions as gfunc# import load.load_data as ldat# import load.load_traces as ltra# import old.old_figs as ofig# import itertools# nb description with pandas:# pd.options.display.max_columns = 30#===========================# global setup# NB fig size : 8.5, 11.6 or 17.6 cmanot = True           # to draw the date and name on the bottom of the plotstd_colors = config.std_colors()speed_colors = config.speed_colors()plt.rcParams.update(config.rc_params())paths = config.build_paths()os.chdir(paths['pg'])paths['data'] = os.path.join(paths['owncFig'], 'data')#%%def load_speed_data():    file = 'baudot.csv'    filename = os.path.join(paths['data'], file)    bddf = pd.read_csv(filename)    file = 'neuron_props_speed.xlsx'    filename = os.path.join(paths['data'], 'averageTraces', file)    cgdf = pd.read_excel(filename)    cols = [st.strip() for st in cgdf.columns]    cols = [st.lower() for st in cols]    cols = [st.replace('(', '_') for st in cols]    cols = [st.replace(')', '') for st in cols]    cgdf.columns = cols    return bddf, cgdfdef build_summary(bddf, cgdf):    """     class the number of cells    input = baudot dataframe & centrigabor dataframe    output = summary dataframe (nb of cells, upper interval spped limit)    """    # count number of cells    def class_speed(s):        "return upper limit in class"        lims = range(100, 500, 25)        i = bisect(lims, s)        return(lims[i])    cgdf['optiMax'] = cgdf.speed_isi0.apply(lambda x: class_speed(x))    cgNumb = dict(cgdf.optiMax.value_counts())    bdNumb = dict(bddf.set_index('optiMax'))    summary_df = pd.DataFrame(index=range(100, 525, 25))    summary_df = summary_df.join(pd.DataFrame(bdNumb))    summary_df.columns = ['bd_cells']    summary_df['cg_cells'] = pd.Series(cgNumb)    return summary_dfdef plot_optimal_speed(df):    fig = plt.figure(figsize=(11.6, 5))    ax = fig.add_subplot(111)    # plot vs uppper limit    x = (df.index - 25).to_list()       # x = summary_df.index.to_list()    height_bd = df.bd_cells.values    height_cg = df.cg_cells.values    # replace nan    height_cg = np.nan_to_num(height_cg, 0)    height_bd = np.nan_to_num(height_bd, 0)    width = 25    align='edge'    # ax.bar([_-10 for _ in x], height=height_cg, width=width, align=align,    #        color='tab:gray', edgecolor='k', label='centrigabor')    ax.bar(x, height=height_bd, width=width, align=align,           color='tab:gray', edgecolor='k', alpha = 0.6, label='baudot')    ax.bar(x, height=height_cg, bottom=height_bd, width=width, align=align,           color='w', edgecolor='k', label='centrigabor')    ax.set_xlabel('{} (°/sec)'.format('optimal apparent speed'.title()))    ax.set_ylabel('nb of Cells')    ax.legend()    for spine in ['top', 'right']:        ax.spines[spine].set_visible(False)    fig.tight_layout()    if anot:        date = datetime.now().strftime('%Y-%m-%d %H:%M:%S')        fig.text(0.99, 0.01, 'speedBaudot.py:plot_optimal_speed',                 ha='right', va='bottom', alpha=0.4)        fig.text(0.01, 0.01, date, ha='left', va='bottom', alpha=0.4)    return figplt.close('all')anot=Trueif not 'bddf' in globals() and 'cgdf' in globals():    bddf, cgdf = load_speed_data()summary_df = build_summary(bddf, cgdf)fig = plot_optimal_speed(summary_df)save = Falseif save:    file = 'optSpeed.pdf'    dirname = os.path.join(paths['owncFig'], 'pythonPreview', 'baudot')    filename = os.path.join(dirname, file)    fig.savefig(filename)#%%def load_bringuier():    filename = os.path.join(paths['data'], 'bringuier.csv')    brdf = pd.read_csv(filename, sep='\t', decimal=',')    brdf.speed_upper = brdf.speed_upper * 100    return brdfbrdf = load_bringuier()#%%plt.close('all')def plot_optimal_bringuier(df):    fig = plt.figure()    ax = fig.add_subplot(111)    # replace nan by O    df = df.fillna(0).astype('int')    #extract & correction for lower limit    x = (df.speed_upper - 5).tolist()    height_imp = df.impulse.tolist()    height_bar = df.long_bar.tolist()    align = 'edge'    x[-1] = 105     # for continuous range    width = max(x)/(len(x) -1)    ax.bar(x, height=height_imp, width=width, align=align,           color='tab:green', edgecolor='k', alpha=0.8, label='impulse')    ax.bar(x, height=height_bar, width=width, align=align, alpha=1,           color='tab:blue', edgecolor='k', label='bar')    ax.set_xlabel('{} (°/sec)'.format('optimal propagation'.title()))    ax.set_ylabel('nb of Cells')    ax.legend()    ax.text(103, 0, '//', ha='center', va='center', backgroundcolor='w')    for spine in ['top', 'right']:        ax.spines[spine].set_visible(False)    fig.tight_layout()    if anot:        date = datetime.now().strftime('%Y-%m-%d %H:%M:%S')        fig.text(0.99, 0.01, 'speedBaudot.py:plot_optimal_bringuier',             ha='right', va='bottom', alpha=0.4)        fig.text(0.01, 0.01, date, ha='left', va='bottom', alpha=0.4)    return figplt.close('all')fig = plot_optimal_bringuier(brdf)save = Falseif save:    file = 'optSpreedBringuier.pdf'    dirname = os.path.join(paths['owncFig'], 'pythonPreview', 'baudot')    filename = os.path.join(dirname, file)    fig.savefig(filename)